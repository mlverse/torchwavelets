% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/transform.R
\name{WaveletTransform}
\alias{WaveletTransform}
\title{Continuous wavelet transform as described in Torrence and Compo,
"A Practical Guide to Wavelet Analysis".}
\description{
Continuous wavelet transform as described in Torrence and Compo,
"A Practical Guide to Wavelet Analysis".

Continuous wavelet transform as described in Torrence and Compo,
"A Practical Guide to Wavelet Analysis".
}
\details{
There is a time-domain as well as a Fourier-domain implementation.
Like _QUVA-Lab/PyTorchWavelets_, the time-domain method uses a filter bank
consisting of `torch::nn_conv1d()` modules. This implementation will work with
batches of signals. The alternative, spectral-domain multiplication followed by
the inverse Fourier transform, is the default. For long signals, and when no
GPU is available, this is the recommended way.
Both implementations expect input sequences to be one-dimensional.
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{filters}}{the filters used in the time-domain implementation}

\item{\code{is_complex_wavelet}}{whether the wavelet has complex values}

\item{\code{convs}}{the `nn_conv1d()` modules used in the time-domain implementation}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-WaveletTransform-new}{\code{WaveletTransform$new()}}
\item \href{#method-WaveletTransform-build_filters}{\code{WaveletTransform$build_filters()}}
\item \href{#method-WaveletTransform-filter_bank}{\code{WaveletTransform$filter_bank()}}
\item \href{#method-WaveletTransform-cwt_time}{\code{WaveletTransform$cwt_time()}}
\item \href{#method-WaveletTransform-cwt_freq}{\code{WaveletTransform$cwt_freq()}}
\item \href{#method-WaveletTransform-cwt}{\code{WaveletTransform$cwt()}}
\item \href{#method-WaveletTransform-compute_optimal_scales}{\code{WaveletTransform$compute_optimal_scales()}}
\item \href{#method-WaveletTransform-power}{\code{WaveletTransform$power()}}
\item \href{#method-WaveletTransform-get_padding}{\code{WaveletTransform$get_padding()}}
\item \href{#method-WaveletTransform-compute_minimum_scale}{\code{WaveletTransform$compute_minimum_scale()}}
\item \href{#method-WaveletTransform-fourier_period}{\code{WaveletTransform$fourier_period()}}
\item \href{#method-WaveletTransform-scale_from_period}{\code{WaveletTransform$scale_from_period()}}
\item \href{#method-WaveletTransform-fourier_periods}{\code{WaveletTransform$fourier_periods()}}
\item \href{#method-WaveletTransform-fourier_frequencies}{\code{WaveletTransform$fourier_frequencies()}}
\item \href{#method-WaveletTransform-coi}{\code{WaveletTransform$coi()}}
\item \href{#method-WaveletTransform-clone}{\code{WaveletTransform$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-WaveletTransform-new"></a>}}
\if{latex}{\out{\hypertarget{method-WaveletTransform-new}{}}}
\subsection{Method \code{new()}}{
initialize the main object, and possibly pre-compute required fields.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{WaveletTransform$new(
  signal_length,
  dt = 1,
  dj = 0.125,
  wavelet = torchwavelets::Morlet$new(),
  fourier = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{signal_length}}{length of the signal to be processed}

\item{\code{dt}}{sample spacing, default is 1}

\item{\code{dj}}{scale distribution parameter, default is 0.125}

\item{\code{wavelet}}{wavelet object}

\item{\code{fourier}}{whether to run in the frequency domain}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-WaveletTransform-build_filters"></a>}}
\if{latex}{\out{\hypertarget{method-WaveletTransform-build_filters}{}}}
\subsection{Method \code{build_filters()}}{
Determines the optimal scale distribution (see Torrence & Compo, Eq. 9-10), and then initializes
the filter bank consisting of re-scaled versions of the mother wavelet. Also includes normalization.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{WaveletTransform$build_filters()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-WaveletTransform-filter_bank"></a>}}
\if{latex}{\out{\hypertarget{method-WaveletTransform-filter_bank}{}}}
\subsection{Method \code{filter_bank()}}{
Given a list of temporal 1D filters of variable size, this method
creates a list of `nn_conv1d()` objects that collectively form the filter bank.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{WaveletTransform$filter_bank(filters, padding_type = "same")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{filters}}{the filters generated by `build_filters()`}

\item{\code{padding_type}}{the type of padding to use with `nn_conv1d()`}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-WaveletTransform-cwt_time"></a>}}
\if{latex}{\out{\hypertarget{method-WaveletTransform-cwt_time}{}}}
\subsection{Method \code{cwt_time()}}{
Takes a batch of signals and convolves each signal with all elements
in the filter bank. After convolving the entire filter bank, the method returns
a tensor of shape `[batch_size,n_scales,1 or 2,T]` (the next-to-last dimension
being of size 1 for real wavelets, 2 for complex ones; and T being the transformed values).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{WaveletTransform$cwt_time(x)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{the input signal}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-WaveletTransform-cwt_freq"></a>}}
\if{latex}{\out{\hypertarget{method-WaveletTransform-cwt_freq}{}}}
\subsection{Method \code{cwt_freq()}}{
Takes a single signal and computes the wavelet transform in the Fourier domain.
The returned value has shape `[n_scales, T]`, where T (the transformed values)
can be a complex tensor.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{WaveletTransform$cwt_freq(x)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{the input signal}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-WaveletTransform-cwt"></a>}}
\if{latex}{\out{\hypertarget{method-WaveletTransform-cwt}{}}}
\subsection{Method \code{cwt()}}{
computes the wavelet transform, either in time or in frequency,
depending on whether `self$fourier` is true or false.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{WaveletTransform$cwt(x)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{the input signal}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-WaveletTransform-compute_optimal_scales"></a>}}
\if{latex}{\out{\hypertarget{method-WaveletTransform-compute_optimal_scales}{}}}
\subsection{Method \code{compute_optimal_scales()}}{
Determines the optimal scale distribution (see Torrence & Compo, Eq. 9-10).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{WaveletTransform$compute_optimal_scales()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-WaveletTransform-power"></a>}}
\if{latex}{\out{\hypertarget{method-WaveletTransform-power}{}}}
\subsection{Method \code{power()}}{
Performs CWT and converts to a power spectrum (scalogram). See Torrence & Compo, Section 4d.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{WaveletTransform$power(x, unbias = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{the input signal}

\item{\code{unbias}}{whether to unbias the power spectrum, as in Liu et al. 2007.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-WaveletTransform-get_padding"></a>}}
\if{latex}{\out{\hypertarget{method-WaveletTransform-get_padding}{}}}
\subsection{Method \code{get_padding()}}{
compute number of padding values desired
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{WaveletTransform$get_padding(padding_type, kernel_size)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{padding_type}}{the padding type to use}

\item{\code{kernel_size}}{the kernel size}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-WaveletTransform-compute_minimum_scale"></a>}}
\if{latex}{\out{\hypertarget{method-WaveletTransform-compute_minimum_scale}{}}}
\subsection{Method \code{compute_minimum_scale()}}{
Choose s0 so that the equivalent Fourier period is 2 * dt. See Torrence & Compo Sections 3f and 3h.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{WaveletTransform$compute_minimum_scale()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-WaveletTransform-fourier_period"></a>}}
\if{latex}{\out{\hypertarget{method-WaveletTransform-fourier_period}{}}}
\subsection{Method \code{fourier_period()}}{
equivalent Fourier period
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{WaveletTransform$fourier_period(s)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{s}}{scaling factor}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-WaveletTransform-scale_from_period"></a>}}
\if{latex}{\out{\hypertarget{method-WaveletTransform-scale_from_period}{}}}
\subsection{Method \code{scale_from_period()}}{
compute the scale from the fourier period
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{WaveletTransform$scale_from_period(p)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{p}}{Fourier period}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-WaveletTransform-fourier_periods"></a>}}
\if{latex}{\out{\hypertarget{method-WaveletTransform-fourier_periods}{}}}
\subsection{Method \code{fourier_periods()}}{
Fourier period corresponding to scales
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{WaveletTransform$fourier_periods()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-WaveletTransform-fourier_frequencies"></a>}}
\if{latex}{\out{\hypertarget{method-WaveletTransform-fourier_frequencies}{}}}
\subsection{Method \code{fourier_frequencies()}}{
Fourier period corresponding to scales
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{WaveletTransform$fourier_frequencies()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-WaveletTransform-coi"></a>}}
\if{latex}{\out{\hypertarget{method-WaveletTransform-coi}{}}}
\subsection{Method \code{coi()}}{
returns a pair of tensors that describes the cone of influence as a curve of time and scales
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{WaveletTransform$coi(t_min, t_max)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{t_min}}{the smallest time value in the signal}

\item{\code{t_max}}{the largest time value in the signal}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-WaveletTransform-clone"></a>}}
\if{latex}{\out{\hypertarget{method-WaveletTransform-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{WaveletTransform$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
